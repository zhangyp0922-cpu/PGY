<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mitosis Tentacles V15 - Radial Explosion</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f2f2f2; }
        canvas { display: block; }
        #ui-container {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            padding: 15px; border-radius: 12px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); z-index: 100;
            display: flex; flex-direction: column; gap: 12px;
            width: 220px;
        }
        label { font-size: 12px; font-weight: bold; color: #555; letter-spacing: 1px; text-transform: uppercase;}
        input[type=range] { width: 100%; cursor: pointer; display: block; accent-color: #333;}
        button {
            padding: 12px 0; cursor: pointer;
            background: #222; color: #fff; border: none;
            border-radius: 6px; font-family: inherit; font-size: 14px; font-weight: bold;
            transition: all 0.1s;
        }
        button:hover { background: #444; transform: scale(1.02); }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>

<div id="ui-container">
    <div>
        <label>Wind Force (æ¼‚æµ®é£åŠ›)</label>
        <input type="range" id="windSlider" min="0" max="3" step="0.01" value="0.5">
    </div>
    <button id="blowBtn">ğŸ’¥ ç‚¸ æ•£ (EXPLODE)</button>
</div>

<script>
    const CONFIG = {
        baseSeedCount: 50,        
        bloomInterval: 1,         
        baseColor: 30,            
        windSpeed: 0.005,
        
        seedsToBlurPerFlower: 5,
        blurStrength: 6,
        
        tentacleSpeed: 0.02,
        minReachRatio: 0.4,
        maxCurveSlack: 100,

        // ç‚¸æ•£åçš„å†ç”Ÿæ—¶é—´
        regrowDelay: 140 
    };

    let flowers = [];
    let airborneSeeds = []; 
    let globalWindTime = 0;
    let windSlider, blowBtn;

    function setup() {
        createCanvas(windowWidth, windowHeight, P2D);
        pixelDensity(1);
        textFont('Courier New, monospace'); 
        frameRate(60); 
        
        windSlider = document.getElementById('windSlider');
        blowBtn = document.getElementById('blowBtn');
        blowBtn.addEventListener('click', triggerExplosion);

        initFlowers();
    }

    function initFlowers() {
        flowers = [];
        flowers.push(new Dandelion(width * 0.5, height + 80, 0.5, 0, 1.2));
        flowers.push(new Dandelion(width * 0.2, height + 60, 0.65, 40, 0.7));
        flowers.push(new Dandelion(width * 0.8, height + 70, 0.55, 80, 0.9));
    }

    function triggerExplosion() {
        // ç‚¹å‡»æŒ‰é’®æ—¶ï¼Œè§¦å‘æ‰€æœ‰èŠ±æœµçš„çˆ†ç‚¸æ–¹æ³•
        for (let flower of flowers) {
            flower.explode();
        }
    }

    function draw() {
        clear();
        background('#f2f2f2');
        
        let userWindForce = parseFloat(windSlider.value);
        globalWindTime += CONFIG.windSpeed;
        
        let windNoise = noise(globalWindTime) - 0.5; 
        let currentWind = windNoise * userWindForce; 

        // 1. æ›´æ–°èŠ±æœµ (èŒå’Œæœªç‚¸å¼€çš„éƒ¨åˆ†)
        for (let flower of flowers) {
            flower.update(currentWind);
            flower.display();
        }

        // 2. æ›´æ–°é£èˆçš„ç§å­ (ç‰©ç†ç²’å­ç³»ç»Ÿ)
        if (airborneSeeds.length > 0) {
            for (let i = airborneSeeds.length - 1; i >= 0; i--) {
                let seed = airborneSeeds[i];
                seed.updateAirborne(userWindForce);
                seed.displayAirborne();

                if (seed.isDead()) {
                    airborneSeeds.splice(i, 1);
                }
            }
        }
    }

    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        initFlowers();
    }

    function easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }

    // --- èŠ±æœµç±» ---
    class Dandelion {
        constructor(x, startY, heightRatio, delay, scale) {
            this.baseX = x; this.baseY = startY; this.scale = scale;
            this.maxStemLen = (startY - (height * heightRatio));
            this.currentStemLen = 0; 
            
            this.state = 'waiting'; 
            this.delayTimer = delay;
            this.regrowTimer = 0;
            this.growProgress = 0;
            
            this.seeds = [];
            this.maxRadius = random(100, 115) * scale;
            
            this.tipX = x; this.tipY = startY; 
            this.stemBendAngle = 0;
            
            this.populateSeeds();
        }

        populateSeeds() {
            this.seeds = [];
            let count = floor(CONFIG.baseSeedCount * this.scale);
            for (let i = 0; i < count; i++) {
                this.seeds.push(new Seed(this.scale, this.maxRadius));
            }
            this.seeds.sort((a, b) => a.z - b.z);
            let blurCount = min(this.seeds.length, CONFIG.seedsToBlurPerFlower);
            for (let i = 0; i < blurCount; i++) this.seeds[i].needsBlur = true;
            this.activeSeedCount = 0;
        }

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šçˆ†ç‚¸é€»è¾‘ ---
        explode() {
            // åªæœ‰å¼€èŠ±çŠ¶æ€æ‰èƒ½ç‚¸
            if (this.state !== 'blooming') return;

            // éå†æ‰€æœ‰å½“å‰å¯è§çš„ç§å­
            for (let i = 0; i < this.activeSeedCount; i++) {
                let s = this.seeds[i];
                
                // 1. è®¡ç®—ç§å­åœ¨è¿™ä¸€å¸§çš„ä¸–ç•Œåæ ‡
                let finalAngle = s.baseAngle; 
                let localX = cos(finalAngle) * s.currentLen;
                let localY = sin(finalAngle) * s.currentLen;
                
                // åŠ ä¸ŠèŒçš„æ—‹è½¬
                let rotatedX = localX * cos(this.stemBendAngle) - localY * sin(this.stemBendAngle);
                let rotatedY = localX * sin(this.stemBendAngle) + localY * cos(this.stemBendAngle);
                
                s.pos = createVector(this.tipX + rotatedX, this.tipY + rotatedY);

                // 2. è®¡ç®—çˆ†å‘é€Ÿåº¦ (Radial Velocity)
                // æ–¹å‘ï¼šä»åœ†å¿ƒæŒ‡å‘ç§å­
                let burstDir = p5.Vector.fromAngle(finalAngle + this.stemBendAngle);
                
                // åŠ›åº¦ï¼šéšæœºçš„å¤§æ•°å€¼ï¼Œåˆ¶é€ å†²å‡»æ„Ÿ
                let explosionForce = random(8, 15); 
                s.vel = burstDir.mult(explosionForce);
                
                // åŠ å…¥åˆ°é£è¡Œåˆ—è¡¨
                airborneSeeds.push(s);
            }

            // æ¸…ç©ºèŠ±æœµï¼Œè¿›å…¥â€œå…‰ç§ƒâ€çŠ¶æ€
            this.seeds = [];
            this.activeSeedCount = 0;
            this.state = 'blown';
            this.regrowTimer = 0; 
        }

        update(wind) {
            if (this.delayTimer > 0) { this.delayTimer--; return; }

            // ç®€å•çš„çŠ¶æ€æœº
            if (this.state === 'waiting') {
                this.state = 'growing';
            }
            else if (this.state === 'growing') {
                this.growProgress += 0.015;
                if (this.growProgress >= 1) { 
                    this.growProgress = 1; 
                    this.state = 'blooming'; 
                }
                this.currentStemLen = lerp(this.currentStemLen, this.maxStemLen, 0.03);
            }
            else if (this.state === 'blooming') {
                // é€ä¸ªå‡ºç°
                if (frameCount % CONFIG.bloomInterval === 0 && this.activeSeedCount < this.seeds.length) {
                    this.seeds[this.activeSeedCount].activate();
                    this.activeSeedCount++;
                }
            }
            else if (this.state === 'blown') {
                // ç‚¸å¼€åèŒç¨å¾®å›ç¼©ï¼Œè¡¨ç°å¾—åƒå¤±å»äº†é‡é‡
                this.currentStemLen = lerp(this.currentStemLen, this.maxStemLen * 0.95, 0.05);
                
                // å†ç”Ÿå€’è®¡æ—¶
                this.regrowTimer++;
                if (this.regrowTimer > CONFIG.regrowDelay) {
                    this.populateSeeds();
                    this.growProgress = 0;
                    this.state = 'growing';
                }
            }

            // ç‰©ç†æ‘‡æ‘†
            let bendMagnitude = wind * (this.currentStemLen / 200) * this.scale; 
            this.stemBendAngle = lerp(this.stemBendAngle, bendMagnitude, 0.08);
            
            this.tipX = this.baseX + cos(-HALF_PI + this.stemBendAngle) * this.currentStemLen;
            this.tipY = this.baseY + sin(-HALF_PI + this.stemBendAngle) * this.currentStemLen;

            // åªæœ‰æœªç‚¸å¼€æ—¶æ‰æ›´æ–°é™„ç€çš„ç§å­
            if (this.state === 'growing' || this.state === 'blooming') {
                for (let i = 0; i < this.activeSeedCount; i++) this.seeds[i].updateAttached();
            }
        }

        display() {
            if (this.delayTimer > 0) return;
            
            // èŒ
            noFill(); stroke(CONFIG.baseColor, 120); strokeWeight(1.2 * this.scale);
            let midX = (this.baseX + this.tipX) / 2; let midY = (this.baseY + this.tipY) / 2;
            let cx = midX - sin(this.stemBendAngle) * 60 * this.scale; 
            bezier(this.baseX, this.baseY, cx, midY, cx, midY, this.tipX, this.tipY);

            push();
            translate(this.tipX, this.tipY);
            rotate(this.stemBendAngle);
            
            // å¤–è½®å»“
            if (this.state !== 'blown' && this.activeSeedCount > 5) {
                noFill(); stroke(CONFIG.baseColor, 20); strokeWeight(0.8);
                let r = this.maxRadius * this.growProgress;
                circle(0, 0, r * 2);
            }

            if (this.state !== 'blown') {
                for (let i = 0; i < this.activeSeedCount; i++) this.seeds[i].displayAttached();
            }
            pop();
        }
    }

    class Seed {
        constructor(scale, maxRadius) {
            this.scale = scale;
            this.baseAngle = random(TWO_PI);
            
            this.maxLen = maxRadius;
            this.minLen = maxRadius * CONFIG.minReachRatio;
            
            this.currentLen = 0;
            this.val = floor(random(0, 10));
            this.z = random(-1, 1); 
            this.needsBlur = false;

            this.cycleOffset = random(TWO_PI); 
            this.cycleSpeed = random(CONFIG.tentacleSpeed * 0.5, CONFIG.tentacleSpeed * 1.5); 
            
            this.curveDir = random() > 0.5 ? 1 : -1;
            this.slackNoise = random(1000);
            
            this.isActive = false; 
            this.growProgress = 0;
            this.reachFactor = 0;

            // ç‰©ç†å±æ€§
            this.pos = createVector(0,0);
            this.vel = createVector(0,0);
            this.angle = 0;
            this.angleVel = random(-0.1, 0.1); 
            this.floatOffset = random(100); 
        }

        activate() { this.isActive = true; }

        updateAttached() {
            if (!this.isActive) return;
            this.growProgress = lerp(this.growProgress, 1, 0.05);
            let rawSine = sin(frameCount * this.cycleSpeed + this.cycleOffset);
            let cycleNorm = (rawSine + 1) / 2;
            this.reachFactor = easeInOutSine(cycleNorm);
            let targetCurrentLen = lerp(this.minLen, this.maxLen, this.reachFactor);
            this.currentLen = targetCurrentLen * this.growProgress;
            
            if (frameCount % floor(random(50, 120)) === 0) this.val = floor(random(0, 10));
        }

        displayAttached() {
            let finalAngle = this.baseAngle;
            let zFactor = map(this.z, -1, 1, 0, 1); 
            let baseAlpha = this.needsBlur ? 60 : map(zFactor, 0, 1, 100, 240);
            let dynamicAlpha = baseAlpha * map(this.reachFactor, 0, 1, 0.7, 1.0);
            let finalAlpha = dynamicAlpha * this.growProgress;
            let weight = map(zFactor, 0, 1, 0.5, 1.4) * this.scale; 
            let size = map(zFactor, 0, 1, 12, 22) * this.scale;   

            let x = cos(finalAngle) * this.currentLen;
            let y = sin(finalAngle) * this.currentLen;

            let slackFactor = 1.0 - this.reachFactor;
            let noiseBend = noise(frameCount * 0.01 + this.slackNoise) * 0.5 + 0.5;
            let currentCurveAmount = CONFIG.maxCurveSlack * slackFactor * noiseBend * this.scale * this.growProgress * this.curveDir;
            
            let cp1Rad = this.currentLen * 0.33;
            let cp2Rad = this.currentLen * 0.66;
            let tanX = -sin(finalAngle); let tanY = cos(finalAngle);
            let cx1 = cos(finalAngle) * cp1Rad + tanX * currentCurveAmount;
            let cy1 = sin(finalAngle) * cp1Rad + tanY * currentCurveAmount;
            let cx2 = cos(finalAngle) * cp2Rad + tanX * currentCurveAmount * 0.8;
            let cy2 = sin(finalAngle) * cp2Rad + tanY * currentCurveAmount * 0.8;
            
            push();
            if (this.needsBlur && this.growProgress > 0.8) drawingContext.filter = `blur(${CONFIG.blurStrength}px)`;
            noFill(); stroke(CONFIG.baseColor, finalAlpha * 0.6); strokeWeight(weight);
            bezier(0, 0, cx1, cy1, cx2, cy2, x, y);
            translate(x, y);
            noStroke(); fill(CONFIG.baseColor, finalAlpha);
            textSize(size); textAlign(CENTER, CENTER);
            let pulseSize = size * (1 + this.reachFactor * 0.1);
            textSize(pulseSize);
            text(this.val, 0, 0);
            if (this.needsBlur) drawingContext.filter = 'none';
            pop();
        }

        // --- æ ¸å¿ƒï¼šçˆ†ç‚¸åçš„ç‰©ç†ç³»ç»Ÿ ---
        updateAirborne(windForce) {
            // 1. è·å–å½“å‰é€Ÿåº¦
            let speed = this.vel.mag();

            // 2. æ¨¡æ‹Ÿç©ºæ°”é˜»åŠ› (Air Resistance)
            // é˜»åŠ›ä¸é€Ÿåº¦çš„å¹³æ–¹æˆæ­£æ¯”ã€‚é€Ÿåº¦è¶Šå¿«ï¼Œé˜»åŠ›è¶Šå¤§ã€‚
            // è¿™ä¼šå¯¼è‡´çˆ†ç‚¸ç¬é—´å‡é€Ÿéå¸¸å¿«ï¼Œäº§ç”Ÿâ€œå˜­â€çš„ä¸€ä¸‹çš„è§†è§‰å¼ åŠ›ã€‚
            let dragMagnitude = speed * speed * 0.08; 
            if (speed > 0) {
                let drag = this.vel.copy().normalize().mult(-dragMagnitude);
                this.vel.add(drag);
            }

            // 3. æ¼‚æµ®é˜¶æ®µ
            // å½“é€Ÿåº¦é™ä¸‹æ¥åï¼Œè®©å®ƒä»¬å—åˆ°å¾®é£å’Œæ¹æµçš„å½±å“
            if (speed < 5) { // é˜ˆå€¼ï¼šé€Ÿåº¦å°äº5æ—¶ï¼Œè¿›å…¥æ¼‚æµ®æ¨¡å¼
                let noiseScale = 0.01;
                let theta = map(noise(this.pos.x * noiseScale, this.pos.y * noiseScale, frameCount * 0.01), 0, 1, -PI, PI);
                
                // æ¹æµåŠ›
                let turbulence = p5.Vector.fromAngle(theta).mult(0.05);
                // ç”¨æˆ·æ»‘å—æ§åˆ¶çš„é£
                let steadyWind = createVector(windForce * 0.05, -0.01 * windForce);
                // å¾®å¼±é‡åŠ›
                let gravity = createVector(0, 0.03);

                this.vel.add(turbulence);
                this.vel.add(steadyWind);
                this.vel.add(gravity);
            }

            this.pos.add(this.vel);

            // æ—‹è½¬è·Ÿéšé€Ÿåº¦æ–¹å‘ï¼Œä½†ä¹Ÿç¨å¾®ä¿ç•™ä¸€ç‚¹è‡ªæ—‹
            this.angle += this.angleVel;
            this.angleVel *= 0.95; // è‡ªæ—‹æ…¢æ…¢åœæ­¢
        }

        displayAirborne() {
            let zFactor = map(this.z, -1, 1, 0, 1); 
            let alpha = this.needsBlur ? 80 : 180;
            let size = map(zFactor, 0, 1, 12, 22) * this.scale;

            push();
            translate(this.pos.x, this.pos.y);
            rotate(this.angle); 

            if (this.needsBlur) drawingContext.filter = `blur(${CONFIG.blurStrength}px)`;

            // ç»’æ¯›å°¾å·´
            let tailWag = sin(frameCount * 0.15 + this.floatOffset) * 4;
            
            noFill();
            stroke(CONFIG.baseColor, alpha * 0.4);
            strokeWeight(0.5);
            // å°¾å·´ç¨å¾®æ‹‰é•¿ä¸€ç‚¹ï¼Œå¢å¼ºé€Ÿåº¦æ„Ÿ
            bezier(0, 0, -5, 5, -10 + tailWag, 5, -15, 0);
            bezier(0, 0, -5, -5, -10 + tailWag, -5, -15, 0);

            noStroke();
            fill(CONFIG.baseColor, alpha);
            textSize(size);
            textAlign(CENTER, CENTER);
            text(this.val, 0, 0);

            if (this.needsBlur) drawingContext.filter = 'none';
            pop();
        }

        isDead() {
            return (this.pos.x > width + 400 || this.pos.y < -400 || this.pos.x < -400 || this.pos.y > height + 200);
        }
    }
</script>

</body>
</html>
